<sect1 id="pg-pathman">
  <title>pg_pathman</title>
  <para>
    The <literal>pg_pathman</literal> module provides optimized
    partitioning mechanism and functions to manage partitions.
  </para>
  <sect2 id="pg-pathman-concepts">
    <title>pg_pathman Concepts</title>
    <para>
      Partitioning refers to splitting one large table into smaller
      pieces. Each row in such table assigns to a single partition based
      on partitioning key. Common partitioning strategies are:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          HASH - maps rows to partitions based on hash function values;
        </para>
      </listitem>
      <listitem>
        <para>
          RANGE - maps data to partitions based on ranges that you
          establish for each partition;
        </para>
      </listitem>
      <listitem>
        <para>
          LIST - maps data to partitions based on explicitly specified
          values of partitioning key for each partition.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      PostgreSQL supports partitioning via table inheritance. Each
      partition must be created as child table with CHECK CONSTRAINT.
      For example:
    </para>
    <programlisting>
CREATE TABLE test (id SERIAL PRIMARY KEY, title TEXT);
CREATE TABLE test_1 (CHECK ( id &gt;= 100 AND id &lt; 200 )) INHERITS (test);
CREATE TABLE test_2 (CHECK ( id &gt;= 200 AND id &lt; 300 )) INHERITS (test);
</programlisting>
    <para>
      Despite the flexibility of this approach it has weakness. If query
      uses filtering the optimizer forced to perform an exhaustive
      search and check constraints for each partition to determine
      partitions from which it should select data. If the number of
      partitions is large the overhead may be significant.
    </para>
    <para>
      The <literal>pg_pathman</literal> module provides functions to
      manage partitions and partitioning mechanism optimized based on
      knowledge of the partitions structure. It stores partitioning
      configuration in the <literal>pathman_config</literal> table, each
      row of which contains single entry for partitioned table (relation
      name, partitioning key and type). During initialization the
      <literal>pg_pathman</literal> module caches information about
      child partitions in shared memory in form convenient to perform
      rapid search. When user executes SELECT query pg_pathman analyzes
      conditions tree looking for conditions like:
    </para>
    <programlisting>
VARIABLE OP CONST
</programlisting>
    <para>
      where <literal>VARIABLE</literal> is partitioning key,
      <literal>OP</literal> is comparison operator (supported operators
      are =, &lt;, &lt;=, &gt;, &gt;=), <literal>CONST</literal> is
      scalar value. For example:
    </para>
    <programlisting>
WHERE id = 150
</programlisting>
    <para>
      Based on partitioning type and operator the
      <literal>pg_pathman</literal> searches corresponding partitions
      and builds the plan.
    </para>
  </sect2>
  <sect2 id="pg-pathman-installation">
    <title>Installation</title>
    <para>
      To install pg_pathman run in psql:
    </para>
    <programlisting>
CREATE EXTENSION pg_pathman;
</programlisting>
    <para>
      Then modify shared_preload_libraries parameter in postgres.conf as
      following:
    </para>
    <programlisting>
shared_preload_libraries = 'pg_pathman'
</programlisting>
    <para>
      It will require to restart the PostgreSQL instance.
    </para>
  </sect2>
  <sect2 id="pg-pathman-functions">
    <title>pg_pathman Functions</title>
    <sect3 id="partitions-creation">
      <title>Partitions Creation</title>
      <programlisting>
create_hash_partitions(
    relation TEXT,
    attribute TEXT,
    partitions_count INTEGER)
</programlisting>
      <para>
        Performs HASH partitioning for <literal>relation</literal> by
        integer key <literal>attribute</literal>. Creates
        <literal>partitions_count</literal> partitions and trigger on
        INSERT. All the data will be automatically copied from the
        parent to partitions.
      </para>
      <programlisting>
create_range_partitions(
    relation TEXT,
    attribute TEXT,
    start_value ANYELEMENT,
    interval ANYELEMENT,
    premake INTEGER)

create_range_partitions(
    relation TEXT,
    attribute TEXT,
    start_value ANYELEMENT,
    interval INTERVAL,
    premake INTEGER)
</programlisting>
      <para>
        Performs RANGE partitioning for <literal>relation</literal> by
        partitioning key <literal>attribute</literal>.
        <literal>start_value</literal> argument specifies initial value,
        <literal>interval</literal> sets the range of values in a single
        partition, <literal>premake</literal> is the number of premade
        partitions. All the data will be automatically copied from the
        parent to partitions.
      </para>
      <programlisting>
create_partitions_from_range(
    relation TEXT,
    attribute TEXT,
    start_value ANYELEMENT,
    end_value ANYELEMENT,
    interval ANYELEMENT)

create_partitions_from_range(
    relation TEXT,
    attribute TEXT,
    start_value ANYELEMENT,
    end_value ANYELEMENT,
    interval INTERVAL)
</programlisting>
      <para>
        Performs RANGE-partitioning from specified range for
        <literal>relation</literal> by partitioning key
        <literal>attribute</literal>. Data will be copied to partitions
        as well.
      </para>
    </sect3>
    <sect3 id="utilities">
      <title>Utilities</title>
      <programlisting>
create_hash_update_trigger(parent TEXT)
</programlisting>
      <para>
        Creates the trigger on UPDATE for HASH partitions. The UPDATE
        trigger isn't created by default because of overhead. It is
        useful in cases when key attribute could be changed.
      </para>
      <programlisting>
create_range_update_trigger(parent TEXT)
</programlisting>
      <para>
        Same as above for RANGE sections.
      </para>
    </sect3>
    <sect3 id="partitions-management">
      <title>Partitions management</title>
      <programlisting>
split_range_partition(partition TEXT, value ANYELEMENT)
</programlisting>
      <para>
        Splits RANGE <literal>partition</literal> in two by
        <literal>value</literal>.
      </para>
      <programlisting>
merge_range_partitions(partition1 TEXT, partition2 TEXT)
</programlisting>
      <para>
        Merge two adjacent RANGE partitions. Data from
        <literal>partition2</literal> is copied to
        <literal>partition1</literal>. Then the
        <literal>partition2</literal> is removed.
      </para>
      <programlisting>
append_partition(p_relation TEXT)
</programlisting>
      <para>
        Appends new partition with the range equal to the range of the
        previous partition.
      </para>
      <programlisting>
prepend_partition(p_relation TEXT)
</programlisting>
      <para>
        Prepends new partition with the range equal to the range of the
        first partition.
      </para>
      <programlisting>
disable_partitioning(relation TEXT)
</programlisting>
      <para>
        Disables <literal>pg_pathman</literal> partitioning mechanism
        for the specified parent table and removes an insert trigger.
        Partitions itself remain unchanged.
      </para>
    </sect3>
  </sect2>
  <sect2 id="examples">
    <title>Examples</title>
    <sect3 id="hash">
      <title>HASH</title>
      <para>
        Consider an example of HASH partitioning. First create a table
        with some integer column:
      </para>
      <programlisting>
CREATE TABLE hash_rel (
    id      SERIAL PRIMARY KEY,
    value   INTEGER);
INSERT INTO hash_rel (value) SELECT g FROM generate_series(1, 10000) as g;
</programlisting>
      <para>
        If partitions are supposed to have indexes, then they should be
        created for parent table before partitioning. In this case
        pg_pathman will automaticaly create indexes for partitions. Then
        run create_hash_partitions() function with appropriate
        arguments:
      </para>
      <programlisting>
SELECT create_hash_partitions('hash_rel', 'value', 100);
</programlisting>
      <para>
        This will create new partitions and move the data from parent to
        partitions. Here is an example of the query with filtering by
        partitioning key and its plan:
      </para>
      <programlisting>
SELECT * FROM hash_rel WHERE value = 1234;
  id  | value 
------+-------
 1234 |  1234

EXPLAIN SELECT * FROM hash_rel WHERE value = 1234;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Append  (cost=0.00..2.00 rows=0 width=0)
   -&gt;  Seq Scan on hash_rel_34  (cost=0.00..2.00 rows=0 width=0)
         Filter: (value = 1234)
</programlisting>
      <para>
        Note that pg_pathman exludes parent table from the query plan.
        To access parent table use ONLY modifier:
      </para>
      <programlisting>
EXPLAIN SELECT * FROM ONLY hash_rel;
                       QUERY PLAN                       
--------------------------------------------------------
 Seq Scan on hash_rel  (cost=0.00..0.00 rows=1 width=8)
</programlisting>
    </sect3>
    <sect3 id="range">
      <title>RANGE</title>
      <para>
        Consider an example of RANGE partitioning. Create a table with
        numerical or date or timestamp column:
      </para>
      <programlisting>
CREATE TABLE range_rel (
    id SERIAL PRIMARY KEY,
    dt TIMESTAMP);
INSERT INTO range_rel (dt) SELECT g FROM generate_series('2010-01-01'::date, '2014-12-31'::date, '1 day') as g;
</programlisting>
      <para>
        Run create_range_partitions() function to create partitions so
        that each partition would contain data for one month:
      </para>
      <programlisting>
SELECT create_range_partitions('range_rel', 'dt', '2010-01-01'::date, '1 month'::interval, 60);
</programlisting>
      <para>
        It will create 60 partitions and move the data from parent to
        partitions. To merge to adjacent partitions run
        merge_range_partitions() function:
      </para>
      <programlisting>
SELECT merge_range_partitions('range_rel_1', 'range_rel_2');
</programlisting>
      <para>
        To split partition use split_range_partition() function:
      </para>
      <programlisting>
SELECT split_range_partition('range_rel_1', '2010-02-15'::date);
</programlisting>
      <para>
        Now let's create new partition. You can use append_partition()
        or prepend_partition() functions:
      </para>
      <programlisting>
SELECT append_partition('range_rel');
</programlisting>
      <para>
        Here is an example of the query with filtering by partitioning
        key and its plan:
      </para>
      <programlisting>
SELECT * FROM range_rel WHERE dt &gt;= '2012-04-30' AND dt &lt;= '2012-05-01';
 id  |         dt          
-----+---------------------
 851 | 2012-04-30 00:00:00
 852 | 2012-05-01 00:00:00

EXPLAIN SELECT * FROM range_rel WHERE dt &gt;= '2012-04-30' AND dt &lt;= '2012-05-01';
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Append  (cost=0.00..60.80 rows=0 width=0)
   -&gt;  Seq Scan on range_rel_28  (cost=0.00..30.40 rows=0 width=0)
         Filter: (dt &gt;= '2012-04-30 00:00:00'::timestamp without time zone)
   -&gt;  Seq Scan on range_rel_29  (cost=0.00..30.40 rows=0 width=0)
         Filter: (dt &lt;= '2012-05-01 00:00:00'::timestamp without time zone)
</programlisting>
    </sect3>
    <sect3 id="disable-pg-pathman">
      <title>Disable pg_pathman</title>
      <para>
        To disable pg_pathman for some previously partitioned table use
        disable_partitioning() function:
      </para>
      <programlisting>
SELECT disable_partitioning('range_rel');
</programlisting>
      <para>
        All sections and data will stay available and will be handled by
        standard PostgreSQL partitioning mechanism. ### Manual
        partitions management It is possible to manage partitions
        manually. After creating or removing child tables it's necessary
        to invoke function:
      </para>
      <programlisting>
on_update_partitions(oid),
</programlisting>
      <para>
        which updates internal structures in memory of
        <literal>pg_pathman module</literal>. For example, let's create
        new section for the <literal>range_rel</literal> from above:
      </para>
      <programlisting>
CREATE TABLE range_rel_archive (CHECK (dt &gt;= '2000-01-01' AND dt &lt; '2010-01-01')) INHERITS (range_rel);
SELECT on_update_partitions('range_rel'::regclass::oid);
</programlisting>
      <para>
        CHECK CONSTRAINT must have the exact format: * (VARIABLE &gt;=
        CONST AND VARIABLE &lt; CONST) for RANGE partitioned tables; *
        (VARIABLE % CONST = CONST) for HASH partitioned tables.
      </para>
      <para>
        It is possible to create partition from foreign table as well:
      </para>
      <programlisting>
CREATE FOREIGN TABLE range_rel_archive (
    id INTEGER NOT NULL,
    dt TIMESTAMP)
SERVER archive_server;
ALTER TABLE range_rel_archive INHERIT range_rel;
ALTER TABLE range_rel_archive ADD CHECK (dt &gt;= '2000-01-01' AND dt &lt; '2010-01-01');
SELECT on_update_partitions('range_rel'::regclass::oid);
</programlisting>
      <para>
        Foreign table structure must exactly match the parent table.
      </para>
      <para>
        In case when parent table is being dropped by DROP TABLE, you
        should invoke on_remove_partitions() function and delete
        particular entry from <literal>pathman_config</literal> table:
      </para>
      <programlisting>
SELECT on_remove_partitions('range_rel'::regclass::oid);
DROP TABLE range_rel CASCADE;
DELETE FROM pathman_config WHERE relname = 'public.range_rel';
</programlisting>
    </sect3>
  </sect2>
  <sect2 id="author">
    <title>Author</title>
    <para>
      Ildar Musin <email>i.musin@postgrespro.ru</email> Postgres
      Professional Ltd., Russia
    </para>
    <para>
      This module is sponsored by Postgres Professional Ltd., Russia
    </para>
  </sect2>
</sect1>

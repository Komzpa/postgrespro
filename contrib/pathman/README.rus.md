# pathman

Модуль `pathman` предоставляет оптимизированный механизм секционирования, а также функции для создания и управления секциями.

## Концепция pathman

Секционирование -- это способ разбиения одной большой таблицы на множество меньших по размеру. Для каждой записи можно однозначно определить секцию, в которой она должна храниться посредством вычисления ключа. Традиционно выделяют три стратегии секционирования:

* HASH - данные равномерно распределяются по секциям в соответствии со значениями hash-функции, вычисленными по некоторому атрибуту;
* RANGE - данные распределяются по секциям, каждая из которых ответственна за заданный диапазон значений аттрибута;
* LIST - для каждой секции определяется набор конкретных значений атрибута.

Секционирование в postgres основано на механизме наследования. Каждому наследнику задается условие CHECK CONSTRAINT. Например:

```
CHECK ( id >= 100 AND id < 200 )
CHECK ( id >= 200 AND id < 300 )
```

Несмотря на гибкость, этот механизм обладает недостатками. Так при фильтрации данных оптимизатор вынужден перебирать все дочерние секции и сравнивать условие запроса с CHECK CONSTRAINT-ами секции, чтобы определить из каких секций ему следует загружать данные. При большом количестве секций это создает дополнительные накладные расходы, которые могут свести на нет выигрыш в производительности от применения секционирования.

Модуль `pathman` предоставляет функции для создания и управления
секциями (см. следующий раздел) и механизм секционирования,
оптимизированный с учетом знания о структуре дочерних таблиц. Конфигурация сохраняется таблице `pathman_config`, каждая строка которой содержит запись для одной секционированной таблицы (название таблицы, атрибут и тип разбиения). В процессе инициализации модуля в разделяемую память сохраняется конфигурация дочерних таблиц в удобном для поиска формате. Получив запрос типа `SELECT` к секционированной таблице, `pathman` анализирует дерево условий запроса и выделяет из него условия вида:

```
ПЕРЕМЕННАЯ ОПЕРАТОР КОНСТАНТА
```
где `ПЕРЕМЕННАЯ` -- это атрибут, по которому было выполнено разбиение, `ОПЕРАТОР` -- оператор сравнения (поддерживаются =, <, <=, >, >=), `КОНСТАНТА` -- скалярное значение. Например:

```
WHERE id = 150
```
Затем основываясь на стратегии секционирования и условиях запроса `pathman` выбирает соответствующие секции и строит план.

## Installation

Для установки pathman выполните в командной строке:
```
CREATE SCHEMA pathman;
CREATE EXTENSION pathman SCHEMA pathman;

```
Затем модифицируйте параметр shared_preload_libraries в конфигурационном файле postgres.conf:
```
shared_preload_libraries = 'pathman'
```
Для вступления изменений в силу потребуется перезагрузка сервера PostgreSQL.

## Функции pathman

### Создание секций
```
create_hash_partitions(
    relation TEXT,
    attribute TEXT,
    partitions_count INTEGER)
```
Выполняет HASH-секционирование таблицы `relation` по целочисленному полю `attribute`. Создает `partitions_count` дочерних секций, а также триггер на вставку. Данные из родительской таблицы не копируются автоматически в дочерние. Миграцию данных можно выполнить с помощью функции `partition_data()` (см. ниже), либо вручную.

```
create_range_partitions(
    relation TEXT,
    attribute TEXT,
    start_value ANYELEMENT,
    interval ANYELEMENT,
    premake INTEGER)
```
Выполняет RANGE-секционирование таблицы `relation` по полю `attribute`. Аргумент `start_value` задает начальное значение, `interval` -- диапазон значений внутри одной секции, `premake` -- количество заранее создаваемых секций (если 0, то будет создана единственная секция).
```
create_range_partitions(
    relation TEXT,
    attribute TEXT,
    start_value ANYELEMENT,
    interval INTERVAL,
    premake INTEGER)
```
Аналогично предыдущей с тем лишь отличием, что данная функция предназначена для секционирования по полю типа `DATE` или `TIMESTAMP`.

### Утилиты
```
partition_data(parent text)
```
Копирует данные из родительской таблицы `parent` в дочерние секции.
```
create_hash_update_trigger(parent TEXT)
```
Создает триггер на UPDATE для HASH секций. По-умолчанию триггер на обновление данных не создается, т.к. это создает дополнительные накладные расходы. Триггер полезен только в том случае, когда меняется значение ключевого аттрибута.
```
create_hash_update_trigger(parent TEXT)
```
Аналогично предыдущей, но для RANGE секций.

### Управление секциями
```
split_range_partition(partition TEXT, value ANYELEMENT)
```
Разбивает RANGE секцию `partition` на две секции по значению `value`.
```
merge_range_partitions(partition1 TEXT, partition2 TEXT)
```
Объединяет две смежные RANGE секции. Данные из `partition2` копируются в `partition1`, после чего секция `partition2` удаляется.
```
append_partition(p_relation TEXT)
```
Добавляет новую секцию в конец списка секций. Диапазон значений устанавливается равным последней секции.
```
prepend_partition(p_relation TEXT)
```
Добавляет новую секцию в начало списка секций.
```
disable_partitioning(relation TEXT)
```
Отключает механизм секционирования `pathman` для заданной таблицы и удаляет триггер на вставку. При этом созданные ранее секции остаются без изменений.

## Примеры использования
### HASH
Рассмотрим пример секционирования таблицы, используя HASH-стратегию на примере таблицы.
```
CREATE TABLE hash_rel (
    id      SERIAL PRIMARY KEY,
    value   INTEGER);
INSERT INTO hash_rel (value) SELECT g FROM generate_series(1, 10000) as g;
```
Разобьем таблицу `hash_rel` на 100 секций по полю `value`:
```
SELECT create_hash_partitions('hash_rel', 'value', 100);
```
Перенесем данные из родительской таблицы в дочерние секции.
```
SELECT partition_data('hash_rel');
```
### RANGE
Пример секционирования таблицы с использованием стратегии RANGE.
```
CREATE TABLE range_rel (
    id SERIAL PRIMARY KEY,
    dt TIMESTAMP);
INSERT INTO range_rel (dt) SELECT g FROM generate_series('2010-01-01'::date, '2015-12-31'::date, '1 day') as g;
```
Разобьем таблицу на 60 секций так, чтобы каждая секция содержала данные за один месяц:
```
SELECT create_range_partitions('range_rel', 'dt', '2010-01-01'::date, '1 month'::interval, 59);
```
> Значение `premake` равно 59, а не 60, т.к. 1 секция создается независимо от значения `premake`

Перенесем данные из родительской таблицы в дочерние секции.
```
SELECT partition_data('range_rel');
```
Объединим секции первые две секции:
```
SELECT merge_range_partitions('range_rel_1', 'range_rel_2');
```
Разделим первую секцию на две по дате '2010-02-15':
```
SELECT split_range_partition('range_rel_1', '2010-02-15'::date);
```
Добавим новую секцию в конец списка секций:
```
SELECT append_partition('range_rel')
```
